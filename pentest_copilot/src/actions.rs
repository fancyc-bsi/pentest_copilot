use crate::types::NmapRun;
use serde_derive::{Deserialize, Serialize};
use std::collections::HashSet;
use std::process::Stdio;
use std::{collections::HashMap, path::PathBuf};
use tokio::fs;
use tokio::process::Command;
use anyhow::anyhow;
use anyhow::{Result, Context};
use crate::report::{PluginReport, Report};

const ALLOWED_EXIT_CODES: [i32; 1] = [1];  

#[derive(Clone, Debug, Serialize, Deserialize, Eq, PartialEq, Hash)]
pub struct Plugin {
    id: u32,
    description: String,
    command: String,
    args: Vec<String>,
    needs_port: bool,
    requires_http: bool, 
    requires_https: bool, 
}



impl Plugin {
    pub async fn execute(&self, target: &str, port: Option<&str>) -> Result<String> {
        let mut command = Command::new(&self.command);
        let mut full_args = self.args.clone();

        if self.needs_port && port.is_some() {
            full_args.push("-p".to_string());
            full_args.push(port.unwrap().to_string());
        }

        let final_target = if self.requires_https {
            format!("https://{}", target)
        } else if self.requires_http {
            format!("http://{}", target)
        } else {
            target.to_string()
        };

        command.args(&full_args);
        command.arg(final_target);
        command.stdin(Stdio::null());
        command.stdout(Stdio::piped());
        command.stderr(Stdio::piped());
        

        let output = command.output().await.context("Failed to execute command")?;
        let status = output.status.code().unwrap_or(-1); 

        // let stdout = String::from_utf8_lossy(&output.stdout);
        // let stderr = String::from_utf8_lossy(&output.stderr);
        // println!("DEBUG: Command stdout: {}", stdout);
        // println!("DEBUG: Command stderr: {}", stderr);
        // println!("DEBUG: Command exit status: {}", status);

        if output.status.success() || ALLOWED_EXIT_CODES.contains(&status) {
            Ok(String::from_utf8(output.stdout)?)
        } else {
            let error_message = String::from_utf8_lossy(&output.stderr);
            println!("Command execution failed: {}", error_message); 
            Err(anyhow!("Command failed: {}", error_message))
        }
    }
}




#[derive(Debug, Deserialize)]
struct Config {
    port_actions: HashMap<String, Vec<u32>>,
    service_actions: HashMap<String, Vec<u32>>,
}

pub struct ReconActions {
    port_actions_map: HashMap<String, Vec<Plugin>>,
    service_actions_map: HashMap<String, Vec<Plugin>>,
    executed_plugins: HashSet<u32>,
}


impl ReconActions {
    pub async fn new() -> Result<Self> {
        let base_path = PathBuf::from("plugins");
        let config_path = base_path.join("config.yaml");
        let config_content = fs::read_to_string(&config_path).await.context("Failed to read config file")?;
        let config: Config = serde_yaml::from_str(&config_content).context("Failed to parse config")?;
        let plugin_map = Self::load_plugins(&base_path).await?;

        Ok(ReconActions {
            port_actions_map: config.port_actions.into_iter()
                .map(|(port, ids)| (port, ids.into_iter().filter_map(|id| plugin_map.get(&id).cloned()).collect()))
                .collect(),
            service_actions_map: config.service_actions.into_iter()
                .map(|(service, ids)| (service, ids.into_iter().filter_map(|id| plugin_map.get(&id).cloned()).collect()))
                .collect(),
            executed_plugins: HashSet::new(),
        })
    }

    async fn load_plugins(base_path: &PathBuf) -> Result<HashMap<u32, Plugin>> {
        let mut plugins = HashMap::new();
        let plugin_pattern = base_path.join("*.yaml");
        let paths = glob::glob(plugin_pattern.to_str().unwrap())?
            .map(Result::unwrap)
            .collect::<Vec<_>>();
    
        for path in paths {
            if path.file_name().unwrap() == "config.yaml" {
                continue; 
            }
            let content = fs::read_to_string(&path).await?;
            // println!("Loading plugin from {}: {}", path.display(), content); // Debug output
            let plugin: Plugin = serde_yaml::from_str(&content)
                .map_err(|e| anyhow!("Failed to parse plugin file at {}: {}", path.display(), e))?;
            plugins.insert(plugin.id, plugin);
        }
        Ok(plugins)
    }
    

    pub async fn determine_actions(&self, nmap_run: &NmapRun) -> HashMap<String, Vec<Plugin>> {
        let mut result = HashMap::new();
        for host in &nmap_run.hosts {
            for port in &host.ports.ports {
                if let Some(actions) = self.port_actions_map.get(&port.portid) {
                    result.entry(port.portid.clone()).or_insert_with(Vec::new).extend(actions.clone());
                }
                if let Some(service_actions) = self.service_actions_map.get(&port.service.name.to_lowercase()) {
                    result.entry(port.portid.clone()).or_insert_with(Vec::new).extend(service_actions.clone());
                }
            }
        }
        result
    }

    pub async fn execute_actions(&mut self, nmap_run: &NmapRun, report: &mut Report) -> Result<()> {
        for host in &nmap_run.hosts {
            for port in &host.ports.ports {
                let actions = self.collect_actions_for_port(&port.portid, &port.service.name);
                
                for plugin in actions {
                    if !self.executed_plugins.insert(plugin.id) {
                        continue; 
                    }
                    
                    let result = plugin.execute(&host.addresses[0].addr, Some(&port.portid)).await?;
                    
                    report.add_report(PluginReport {
                        id: plugin.id,
                        description: plugin.description.clone(),
                        target: host.addresses[0].addr.clone(),
                        port: port.portid.clone(),
                        output: result,
                    });
                }
            }
        }
        Ok(())
    }
    

    fn collect_actions_for_port(&self, port: &str, service: &str) -> Vec<Plugin> {
        let mut actions = Vec::new();

        if let Some(port_actions) = self.port_actions_map.get(port) {
            actions.extend(port_actions.clone());
        }
        if let Some(service_actions) = self.service_actions_map.get(&service.to_lowercase()) {
            actions.extend(service_actions.clone());
        }

        actions
    }
    
}
