use pentest_copilot::*;
use clap::{Arg, Command};
use tokio::fs::{self, File};
use tokio::io::{AsyncBufReadExt, AsyncWriteExt, BufReader};
use actions::ReconActions;
use report::Report;
use render::Renderer;
use logger::Logger;
use anyhow::{Context, Result};

#[tokio::main]
async fn main() -> Result<()> {
    let matches = Command::new("Rust Recon Tool")
        .version("0.1.0")
        .author("Your Name <your.email@example.com>")
        .about("Automates initial reconnaissance for pentesting")
        .arg(Arg::new("target")
            .short('t')
            .long("target")
            .takes_value(true)
            .help("Target IP or hostname to scan"))
        .arg(Arg::new("file")
            .short('f')
            .long("file")
            .takes_value(true)
            .help("File containing target IPs or hostnames"))
        .get_matches();

    let target_file = matches.value_of("file");
    let target_option = matches.value_of("target");

    Logger::info("Checking for plugin updates...");

    fetch_plugins::ensure_plugins_exist().await?;
    Logger::success("Plugins are up to date");

    let targets = if let Some(file_path) = target_file {
        Logger::info(&format!("Reading targets from file '{}'", file_path));
        read_targets_from_file(file_path).await?
    } else if let Some(target) = target_option {
        Logger::info(&format!("Using single target '{}'", target));
        vec![target.to_string()]
    } else {
        Logger::error("No targets specified");
        return Err(anyhow::anyhow!("No targets specified"));
    };

    let mut report = Report::new();

    for target in targets {
        Logger::info(&format!("Starting scan for {}", &target));

        match nmap::run_nmap(&target) {
            Ok(xml_results) => {
                report.add_nmap_result(&target, xml_results.clone());
                if let Ok(nmap_run) = parser::parse_nmap_output(&xml_results) {
                    if nmap_run.hosts.is_empty() {
                        Logger::error("No hosts found, check XML structure and Rust structs alignment.");
                    } else {
                        let mut recon_actions = ReconActions::new().await.unwrap();
                        if let Err(e) = recon_actions.execute_actions(&nmap_run, &mut report).await {
                            Logger::error(&format!("Failed to execute actions: {}", e));
                        }
                    }
                } else {
                    Logger::error("Error parsing XML");
                }
            }
            Err(e) => Logger::error(&format!("Failed to run nmap: {}", e)),
        }
    }

    let markdown_report = report.generate_markdown();
    let html_report = Renderer::render_to_html(&markdown_report);
    let mut file = File::create("scan_report.html").await?;
    file.write_all(html_report.as_bytes()).await?;
    Logger::success("HTML report saved to 'scan_report.html'.");

    Ok(())
}

async fn read_targets_from_file(file_path: &str) -> Result<Vec<String>> {
    let file = fs::File::open(file_path)
        .await
        .context("Failed to open target file")?;
    let reader = BufReader::new(file);
    let mut targets = vec![];
    let mut lines = reader.lines();

    while let Some(line) = lines.next_line().await? {
        if !line.trim().is_empty() {
            targets.push(line.trim().to_string());
        }
    }

    Ok(targets)
}
